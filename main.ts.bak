import { Plugin, PluginSettingTab, App, Setting, Notice, TFolder, TFile, Modal } from 'obsidian';
import * as fs from 'fs';
import * as path from 'path';

interface Snapshot {
  id: string;
  timestamp: number;
  name: string;
  description: string;
  fileCount: number;
  size: number;
}

interface SnapshotData {
  [key: string]: Snapshot;
}

interface PluginSettings {
  snapshotDir: string;
  autoSnapshot: boolean;
  autoSnapshotInterval: number; // 分钟
  maxSnapshots: number;
}

const DEFAULT_SETTINGS: PluginSettings = {
  snapshotDir: '.snapshots',
  autoSnapshot: false,
  autoSnapshotInterval: 60,
  maxSnapshots: 20,
};

export default class SnapshotVersionControl extends Plugin {
  settings: PluginSettings;
  snapshotMetadata: SnapshotData = {};
  autoSnapshotInterval: NodeJS.Timeout;

  async onload() {
    await this.loadSettings();
    this.registerCommands();
    this.addSettingTab(new SnapshotSettingTab(this.app, this));
    
    // 初始化快照目录
    await this.initSnapshotDir();
    
    // 加载现有快照元数据
    await this.loadSnapshotMetadata();
    
    // 启动自动快照（如果启用）
    if (this.settings.autoSnapshot) {
      this.startAutoSnapshot();
    }
  }

  onunload() {
    if (this.autoSnapshotInterval) {
      clearInterval(this.autoSnapshotInterval);
    }
  }

  private registerCommands() {
    // 创建快照命令
    this.addCommand({
      id: 'create-snapshot',
      name: '创建快照',
      callback: () => this.createSnapshotWithDialog(),
    });

    // 列出所有快照命令
    this.addCommand({
      id: 'list-snapshots',
      name: '查看快照列表',
      callback: () => this.showSnapshotList(),
    });

    // 恢复快照命令
    this.addCommand({
      id: 'restore-snapshot',
      name: '恢复快照',
      callback: () => this.restoreSnapshotDialog(),
    });

    // 删除快照命令
    this.addCommand({
      id: 'delete-snapshot',
      name: '删除快照',
      callback: () => this.deleteSnapshotDialog(),
    });

    // 比较快照命令
    this.addCommand({
      id: 'compare-snapshots',
      name: '比较快照',
      callback: () => this.compareSnapshotsDialog(),
    });
  }

  private async initSnapshotDir() {
    const snapshotPath = path.join(this.app.vault.adapter.basePath, this.settings.snapshotDir);
    
    if (!fs.existsSync(snapshotPath)) {
      fs.mkdirSync(snapshotPath, { recursive: true });
    }
  }

  private async loadSnapshotMetadata() {
    const metadataPath = path.join(
      this.app.vault.adapter.basePath,
      this.settings.snapshotDir,
      'metadata.json'
    );

    if (fs.existsSync(metadataPath)) {
      const data = fs.readFileSync(metadataPath, 'utf-8');
      this.snapshotMetadata = JSON.parse(data);
    } else {
      this.snapshotMetadata = {};
    }
  }

  private async saveSnapshotMetadata() {
    const metadataPath = path.join(
      this.app.vault.adapter.basePath,
      this.settings.snapshotDir,
      'metadata.json'
    );

    fs.writeFileSync(metadataPath, JSON.stringify(this.snapshotMetadata, null, 2));
  }

  private async createSnapshotWithDialog() {
    new SnapshotNameModal(this.app, (name, description) => {
      this.createSnapshot(name, description);
    }).open();
  }

  private async createSnapshot(name: string, description: string = '') {
    try {
      const timestamp = Date.now();
      const snapshotId = `snapshot_${timestamp}`;
      const snapshotPath = path.join(
        this.app.vault.adapter.basePath,
        this.settings.snapshotDir,
        snapshotId
      );

      // 创建快照目录
      fs.mkdirSync(snapshotPath, { recursive: true });

      // 复制文件
      const vaultPath = this.app.vault.adapter.basePath;
      let fileCount = 0;
      let totalSize = 0;

      const copyRecursive = (src: string, dest: string) => {
        if (!fs.existsSync(dest)) {
          fs.mkdirSync(dest, { recursive: true });
        }

        const files = fs.readdirSync(src);
        files.forEach((file) => {
          const srcPath = path.join(src, file);
          const destPath = path.join(dest, file);

          // 跳过快照目录和其他隐藏目录
          if (file.startsWith('.') || file === this.settings.snapshotDir) {
            return;
          }

          const stat = fs.statSync(srcPath);
          if (stat.isDirectory()) {
            copyRecursive(srcPath, destPath);
          } else {
            fs.copyFileSync(srcPath, destPath);
            fileCount++;
            totalSize += stat.size;
          }
        });
      };

      copyRecursive(vaultPath, snapshotPath);

      // 保存快照元数据
      this.snapshotMetadata[snapshotId] = {
        id: snapshotId,
        timestamp,
        name,
        description,
        fileCount,
        size: totalSize,
      };

      await this.saveSnapshotMetadata();

      // 清理旧快照
      await this.cleanOldSnapshots();

      new Notice(`✅ 快照 "${name}" 创建成功！`);
    } catch (error) {
      new Notice(`❌ 创建快照失败: ${error}`);
      console.error(error);
    }
  }

  private async restoreSnapshotDialog() {
    const snapshots = Object.values(this.snapshotMetadata).sort(
      (a, b) => b.timestamp - a.timestamp
    );

    if (snapshots.length === 0) {
      new Notice('没有可用的快照');
      return;
    }

    new SnapshotSelectionModal(this.app, snapshots, (snapshot) => {
      new RestoreConfirmModal(this.app, snapshot, () => {
        this.restoreSnapshot(snapshot.id);
      }).open();
    }).open();
  }

  private async restoreSnapshot(snapshotId: string) {
    try {
      const snapshot = this.snapshotMetadata[snapshotId];
      if (!snapshot) {
        new Notice('快照不存在');
        return;
      }

      // 备份当前状态
      await this.createSnapshot(`Before restoring: ${snapshot.name}`, 'Auto backup');

      const snapshotPath = path.join(
        this.app.vault.adapter.basePath,
        this.settings.snapshotDir,
        snapshotId
      );

      const vaultPath = this.app.vault.adapter.basePath;

      // 清空当前文件（除了.snapshots目录）
      const clearVault = (dir: string) => {
        const files = fs.readdirSync(dir);
        files.forEach((file) => {
          if (file.startsWith('.') || file === this.settings.snapshotDir) {
            return;
          }

          const filePath = path.join(dir, file);
          const stat = fs.statSync(filePath);
          if (stat.isDirectory()) {
            clearVault(filePath);
            if (fs.readdirSync(filePath).length === 0) {
              fs.rmdirSync(filePath);
            }
          } else {
            fs.unlinkSync(filePath);
          }
        });
      };

      clearVault(vaultPath);

      // 恢复快照文件
      const restoreRecursive = (src: string, dest: string) => {
        const files = fs.readdirSync(src);
        files.forEach((file) => {
          const srcPath = path.join(src, file);
          const destPath = path.join(dest, file);
          const stat = fs.statSync(srcPath);

          if (stat.isDirectory()) {
            fs.mkdirSync(destPath, { recursive: true });
            restoreRecursive(srcPath, destPath);
          } else {
            fs.copyFileSync(srcPath, destPath);
          }
        });
      };

      restoreRecursive(snapshotPath, vaultPath);

      // 刷新Obsidian
      await this.app.vault.adapter.fs.promises.readdir(vaultPath);

      new Notice(`✅ 快照 "${snapshot.name}" 恢复成功！`);
    } catch (error) {
      new Notice(`❌ 恢复快照失败: ${error}`);
      console.error(error);
    }
  }

  private async deleteSnapshotDialog() {
    const snapshots = Object.values(this.snapshotMetadata).sort(
      (a, b) => b.timestamp - a.timestamp
    );

    if (snapshots.length === 0) {
      new Notice('没有可用的快照');
      return;
    }

    new SnapshotSelectionModal(this.app, snapshots, (snapshot) => {
      new DeleteConfirmModal(this.app, snapshot, () => {
        this.deleteSnapshot(snapshot.id);
      }).open();
    }).open();
  }

  private async deleteSnapshot(snapshotId: string) {
    try {
      const snapshot = this.snapshotMetadata[snapshotId];
      const snapshotPath = path.join(
        this.app.vault.adapter.basePath,
        this.settings.snapshotDir,
        snapshotId
      );

      // 递归删除目录
      const removeRecursive = (dir: string) => {
        const files = fs.readdirSync(dir);
        files.forEach((file) => {
          const filePath = path.join(dir, file);
          const stat = fs.statSync(filePath);
          if (stat.isDirectory()) {
            removeRecursive(filePath);
            fs.rmdirSync(filePath);
          } else {
            fs.unlinkSync(filePath);
          }
        });
      };

      removeRecursive(snapshotPath);
      fs.rmdirSync(snapshotPath);

      delete this.snapshotMetadata[snapshotId];
      await this.saveSnapshotMetadata();

      new Notice(`✅ 快照 "${snapshot.name}" 已删除`);
    } catch (error) {
      new Notice(`❌ 删除快照失败: ${error}`);
      console.error(error);
    }
  }

  private async compareSnapshotsDialog() {
    const snapshots = Object.values(this.snapshotMetadata).sort(
      (a, b) => b.timestamp - a.timestamp
    );

    if (snapshots.length < 2) {
      new Notice('至少需要2个快照进行比较');
      return;
    }

    new Notice('功能开发中：快照比较');
  }

  private showSnapshotList() {
    const snapshots = Object.values(this.snapshotMetadata).sort(
      (a, b) => b.timestamp - a.timestamp
    );

    if (snapshots.length === 0) {
      new Notice('暂无快照');
      return;
    }

    let content = '## 快照列表\n\n';
    snapshots.forEach((snapshot, index) => {
      const date = new Date(snapshot.timestamp).toLocaleString('zh-CN');
      const sizeInKB = (snapshot.size / 1024).toFixed(2);
      content += `${index + 1}. **${snapshot.name}**\n`;
      content += `   - 时间: ${date}\n`;
      content += `   - 文件数: ${snapshot.fileCount}\n`;
      content += `   - 大小: ${sizeInKB} KB\n`;
      if (snapshot.description) {
        content += `   - 说明: ${snapshot.description}\n`;
      }
      content += '\n';
    });

    new Notice(content);
  }

  private async cleanOldSnapshots() {
    const snapshots = Object.values(this.snapshotMetadata).sort(
      (a, b) => b.timestamp - a.timestamp
    );

    if (snapshots.length > this.settings.maxSnapshots) {
      const toDelete = snapshots.slice(this.settings.maxSnapshots);
      for (const snapshot of toDelete) {
        await this.deleteSnapshot(snapshot.id);
      }
    }
  }

  private startAutoSnapshot() {
    this.autoSnapshotInterval = setInterval(
      () => this.createSnapshot('Auto snapshot', 'Automatically created'),
      this.settings.autoSnapshotInterval * 60 * 1000
    );
  }

  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }
}

class SnapshotSettingTab extends PluginSettingTab {
  plugin: SnapshotVersionControl;

  constructor(app: App, plugin: SnapshotVersionControl) {
    super(app, plugin);
    this.plugin = plugin;
  }

  display(): void {
    const { containerEl } = this;
    containerEl.empty();

    new Setting(containerEl)
      .setName('快照目录')
      .setDesc('存储快照的目录')
      .addText((text) =>
        text
          .setPlaceholder('.snapshots')
          .setValue(this.plugin.settings.snapshotDir)
          .onChange(async (value) => {
            this.plugin.settings.snapshotDir = value;
            await this.plugin.saveSettings();
          })
      );

    new Setting(containerEl)
      .setName('自动快照')
      .setDesc('启用自动创建快照')
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.autoSnapshot)
          .onChange(async (value) => {
            this.plugin.settings.autoSnapshot = value;
            await this.plugin.saveSettings();
            if (value) {
              this.plugin.startAutoSnapshot();
            } else if (this.plugin.autoSnapshotInterval) {
              clearInterval(this.plugin.autoSnapshotInterval);
            }
          })
      );

    new Setting(containerEl)
      .setName('自动快照间隔')
      .setDesc('分钟')
      .addSlider((slider) =>
        slider
          .setLimits(5, 1440, 5)
          .setValue(this.plugin.settings.autoSnapshotInterval)
          .onChange(async (value) => {
            this.plugin.settings.autoSnapshotInterval = value;
            await this.plugin.saveSettings();
          })
      );

    new Setting(containerEl)
      .setName('最大快照数')
      .setDesc('超过此数量时自动删除最旧的快照')
      .addSlider((slider) =>
        slider
          .setLimits(5, 100, 1)
          .setValue(this.plugin.settings.maxSnapshots)
          .onChange(async (value) => {
            this.plugin.settings.maxSnapshots = value;
            await this.plugin.saveSettings();
          })
      );
  }
}

class SnapshotNameModal extends Modal {
  name: string = '';
  description: string = '';

  constructor(app: App, private onSubmit: (name: string, desc: string) => void) {
    super(app);
  }

  onOpen() {
    const { contentEl } = this;

    contentEl.createEl('h2', { text: '创建快照' });

    const form = contentEl.createEl('form');

    const nameInput = form.createEl('input', {
      type: 'text',
      placeholder: '快照名称',
    });
    nameInput.style.width = '100%';
    nameInput.style.marginBottom = '10px';
    nameInput.style.padding = '5px';

    const descInput = form.createEl('textarea', {
      placeholder: '快照描述（可选）',
    });
    descInput.style.width = '100%';
    descInput.style.marginBottom = '10px';
    descInput.style.padding = '5px';

    const buttonContainer = form.createEl('div', { cls: 'modal-button-container' });
    const submitBtn = buttonContainer.createEl('button', { text: '创建', type: 'submit' });
    const cancelBtn = buttonContainer.createEl('button', { text: '取消', type: 'button' });

    form.addEventListener('submit', (e) => {
      e.preventDefault();
      if (nameInput.value.trim()) {
        this.onSubmit(nameInput.value.trim(), descInput.value.trim());
        this.close();
      }
    });

    cancelBtn.addEventListener('click', () => this.close());
  }
}

class SnapshotSelectionModal extends Modal {
  constructor(
    app: App,
    private snapshots: Snapshot[],
    private onSelect: (snapshot: Snapshot) => void
  ) {
    super(app);
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.createEl('h2', { text: '选择快照' });

    const list = contentEl.createEl('ul');
    this.snapshots.forEach((snapshot) => {
      const item = list.createEl('li');
      const date = new Date(snapshot.timestamp).toLocaleString('zh-CN');
      item.createEl('strong', { text: snapshot.name });
      item.createEl('br');
      item.createEl('small', { text: `${date} - ${snapshot.fileCount} 文件` });

      item.style.cursor = 'pointer';
      item.style.padding = '10px';
      item.style.marginBottom = '5px';
      item.style.border = '1px solid var(--background-secondary)';
      item.style.borderRadius = '4px';

      item.addEventListener('click', () => {
        this.onSelect(snapshot);
        this.close();
      });
    });
  }
}

class RestoreConfirmModal extends Modal {
  constructor(
    app: App,
    private snapshot: Snapshot,
    private onConfirm: () => void
  ) {
    super(app);
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.createEl('h2', { text: '确认恢复' });
    contentEl.createEl('p', {
      text: `确定要恢复快照 "${this.snapshot.name}" 吗？\n当前工作区会被保存为备份。`,
    });

    const buttonContainer = contentEl.createEl('div', { cls: 'modal-button-container' });
    const confirmBtn = buttonContainer.createEl('button', { text: '确认恢复', cls: 'mod-cta' });
    const cancelBtn = buttonContainer.createEl('button', { text: '取消' });

    confirmBtn.addEventListener('click', () => {
      this.onConfirm();
      this.close();
    });

    cancelBtn.addEventListener('click', () => this.close());
  }
}

class DeleteConfirmModal extends Modal {
  constructor(
    app: App,
    private snapshot: Snapshot,
    private onConfirm: () => void
  ) {
    super(app);
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.createEl('h2', { text: '确认删除' });
    contentEl.createEl('p', {
      text: `确定要删除快照 "${this.snapshot.name}" 吗？此操作不可撤销。`,
    });

    const buttonContainer = contentEl.createEl('div', { cls: 'modal-button-container' });
    const deleteBtn = buttonContainer.createEl('button', { text: '删除', cls: 'mod-warning' });
    const cancelBtn = buttonContainer.createEl('button', { text: '取消' });

    deleteBtn.addEventListener('click', () => {
      this.onConfirm();
      this.close();
    });

    cancelBtn.addEventListener('click', () => this.close());
  }
}