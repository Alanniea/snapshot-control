import { App, Plugin, PluginSettingTab, Setting, TFile, Notice, Modal, Menu } from 'obsidian';
import * as Diff from 'diff';

interface VersionMetadata {
    id: string;
    timestamp: number;
    message: string;
    size: number;
    isAutoSave: boolean;
}

interface VersionControlSettings {
    versionFolder: string;
    autoSaveEnabled: boolean;
    autoSaveInterval: number;
    autoCleanEnabled: boolean;
    maxVersions: number;
    maxVersionsEnabled: boolean;
    maxDays: number;
    maxDaysEnabled: boolean;
    useRelativeTime: boolean;
    diffGranularity: 'char' | 'word' | 'line';
    diffViewMode: 'unified' | 'split';
}

const DEFAULT_SETTINGS: VersionControlSettings = {
    versionFolder: '.versions',
    autoSaveEnabled: true,
    autoSaveInterval: 5,
    autoCleanEnabled: true,
    maxVersions: 50,
    maxVersionsEnabled: true,
    maxDays: 30,
    maxDaysEnabled: false,
    useRelativeTime: false,
    diffGranularity: 'char',
    diffViewMode: 'unified'
};

export default class VersionControlPlugin extends Plugin {
    settings: VersionControlSettings;
    autoSaveIntervalId: number | null = null;
    modifiedFiles: Set<string> = new Set();

    async onload() {
        await this.loadSettings();

        // 确保版本文件夹存在
        await this.ensureVersionFolder();

        // 添加侧边栏视图
        this.registerView(
            'version-history-view',
            (leaf) => new VersionHistoryView(leaf, this)
        );

        // 添加命令
        this.addCommand({
            id: 'create-manual-version',
            name: '手动创建版本',
            callback: () => this.createManualVersion()
        });

        this.addCommand({
            id: 'show-version-history',
            name: '显示版本历史',
            callback: () => this.showVersionHistory()
        });

        this.addCommand({
            id: 'create-vault-snapshot',
            name: '创建全库快照',
            callback: () => this.createVaultSnapshot()
        });

        // 添加右键菜单
        this.registerEvent(
            this.app.workspace.on('file-menu', (menu, file) => {
                if (file instanceof TFile) {
                    menu.addItem((item) => {
                        item
                            .setTitle('版本历史')
                            .setIcon('history')
                            .onClick(() => this.showVersionHistoryForFile(file));
                    });
                }
            })
        );

        // 监听文件修改
        this.registerEvent(
            this.app.vault.on('modify', (file) => {
                if (file instanceof TFile && !file.path.startsWith(this.settings.versionFolder)) {
                    this.modifiedFiles.add(file.path);
                }
            })
        );

        // 启动自动保存
        if (this.settings.autoSaveEnabled) {
            this.startAutoSave();
        }

        // 添加设置标签页
        this.addSettingTab(new VersionControlSettingTab(this.app, this));
    }

    async onunload() {
        this.stopAutoSave();
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }

    async ensureVersionFolder() {
        const folderPath = this.settings.versionFolder;
        if (!(await this.app.vault.adapter.exists(folderPath))) {
            await this.app.vault.adapter.mkdir(folderPath);
        }
    }

    startAutoSave() {
        this.stopAutoSave();
        const intervalMs = this.settings.autoSaveInterval * 60 * 1000;
        this.autoSaveIntervalId = window.setInterval(() => {
            this.performAutoSave();
        }, intervalMs);
    }

    stopAutoSave() {
        if (this.autoSaveIntervalId !== null) {
            window.clearInterval(this.autoSaveIntervalId);
            this.autoSaveIntervalId = null;
        }
    }

    async performAutoSave() {
        if (this.modifiedFiles.size === 0) return;

        const files = Array.from(this.modifiedFiles);
        this.modifiedFiles.clear();

        for (const filePath of files) {
            const file = this.app.vault.getAbstractFileByPath(filePath);
            if (file instanceof TFile) {
                await this.createVersion(file, '[Auto Save]', true);
            }
        }

        if (this.settings.autoCleanEnabled) {
            await this.cleanOldVersions();
        }
    }

    async createVersion(file: TFile, message: string, isAutoSave: boolean = false): Promise<void> {
        const content = await this.app.vault.read(file);
        const timestamp = Date.now();
        const id = `${timestamp}`;
        
        const versionPath = `${this.settings.versionFolder}/${file.path}`;
        const versionFolder = versionPath.substring(0, versionPath.lastIndexOf('/'));
        
        if (!(await this.app.vault.adapter.exists(versionFolder))) {
            await this.app.vault.adapter.mkdir(versionFolder);
        }

        const metadata: VersionMetadata = {
            id,
            timestamp,
            message,
            size: content.length,
            isAutoSave
        };

        const versionFile = `${versionPath}/${id}.md`;
        const metaFile = `${versionPath}/${id}.json`;

        await this.app.vault.adapter.write(versionFile, content);
        await this.app.vault.adapter.write(metaFile, JSON.stringify(metadata, null, 2));

        if (!isAutoSave) {
            new Notice('版本创建成功');
        }
    }

    async createManualVersion() {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
            new Notice('没有活动文件');
            return;
        }

        new CommitMessageModal(this.app, async (message) => {
            await this.createVersion(activeFile, message, false);
        }).open();
    }

    async createVaultSnapshot() {
        new Notice('正在创建全库快照...');
        const files = this.app.vault.getMarkdownFiles();
        const timestamp = Date.now();
        
        for (const file of files) {
            if (!file.path.startsWith(this.settings.versionFolder)) {
                await this.createVersion(file, `[Vault Snapshot ${timestamp}]`, false);
            }
        }
        
        new Notice(`全库快照创建完成 (${files.length} 个文件)`);
    }

    async getVersions(file: TFile): Promise<VersionMetadata[]> {
        const versionPath = `${this.settings.versionFolder}/${file.path}`;
        
        if (!(await this.app.vault.adapter.exists(versionPath))) {
            return [];
        }

        const files = await this.app.vault.adapter.list(versionPath);
        const versions: VersionMetadata[] = [];

        for (const metaFile of files.files) {
            if (metaFile.endsWith('.json')) {
                const content = await this.app.vault.adapter.read(metaFile);
                versions.push(JSON.parse(content));
            }
        }

        return versions.sort((a, b) => b.timestamp - a.timestamp);
    }

    async restoreVersion(file: TFile, versionId: string) {
        const confirmed = await this.showRestoreConfirmation();
        if (!confirmed) return;

        // 备份当前版本
        await this.createVersion(file, '[Pre-restore backup]', false);

        const versionFile = `${this.settings.versionFolder}/${file.path}/${versionId}.md`;
        const content = await this.app.vault.adapter.read(versionFile);
        await this.app.vault.modify(file, content);

        new Notice('版本已恢复');
    }

    async showRestoreConfirmation(): Promise<boolean> {
        return new Promise((resolve) => {
            new ConfirmModal(
                this.app,
                '确认恢复',
                '当前未保存的修改将会丢失。是否继续?',
                resolve
            ).open();
        });
    }

    async deleteVersion(file: TFile, versionId: string) {
        const versionPath = `${this.settings.versionFolder}/${file.path}`;
        await this.app.vault.adapter.remove(`${versionPath}/${versionId}.md`);
        await this.app.vault.adapter.remove(`${versionPath}/${versionId}.json`);
        new Notice('版本已删除');
    }

    async cleanOldVersions() {
        const files = this.app.vault.getMarkdownFiles();
        
        for (const file of files) {
            if (file.path.startsWith(this.settings.versionFolder)) continue;
            
            const versions = await this.getVersions(file);
            const toDelete: string[] = [];

            if (this.settings.maxVersionsEnabled && versions.length > this.settings.maxVersions) {
                toDelete.push(...versions.slice(this.settings.maxVersions).map(v => v.id));
            }

            if (this.settings.maxDaysEnabled) {
                const cutoffTime = Date.now() - (this.settings.maxDays * 24 * 60 * 60 * 1000);
                toDelete.push(...versions.filter(v => v.timestamp < cutoffTime).map(v => v.id));
            }

            for (const versionId of [...new Set(toDelete)]) {
                await this.deleteVersion(file, versionId);
            }
        }
    }

    async getStorageStats() {
        const versionFolder = this.settings.versionFolder;
        if (!(await this.app.vault.adapter.exists(versionFolder))) {
            return { totalSize: 0, versionCount: 0, fileCount: 0 };
        }

        let totalSize = 0;
        let versionCount = 0;
        const uniqueFiles = new Set<string>();

        const processFolder = async (path: string) => {
            const list = await this.app.vault.adapter.list(path);
            
            for (const file of list.files) {
                if (file.endsWith('.md')) {
                    const stat = await this.app.vault.adapter.stat(file);
                    totalSize += stat?.size || 0;
                    versionCount++;
                    
                    const relativePath = file.replace(`${versionFolder}/`, '').split('/').slice(0, -1).join('/');
                    uniqueFiles.add(relativePath);
                }
            }

            for (const folder of list.folders) {
                await processFolder(folder);
            }
        };

        await processFolder(versionFolder);

        return {
            totalSize,
            versionCount,
            fileCount: uniqueFiles.size
        };
    }

    showVersionHistory() {
        this.app.workspace.getRightLeaf(false).setViewState({
            type: 'version-history-view',
            active: true,
        });
    }

    showVersionHistoryForFile(file: TFile) {
        const leaf = this.app.workspace.getRightLeaf(false);
        leaf.setViewState({
            type: 'version-history-view',
            active: true,
        });
    }

    formatTime(timestamp: number): string {
        if (this.settings.useRelativeTime) {
            return this.getRelativeTime(timestamp);
        }
        return new Date(timestamp).toLocaleString('zh-CN');
    }

    getRelativeTime(timestamp: number): string {
        const diff = Date.now() - timestamp;
        const seconds = Math.floor(diff / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) return `${days}天前`;
        if (hours > 0) return `${hours}小时前`;
        if (minutes > 0) return `${minutes}分钟前`;
        return '刚刚';
    }

    formatBytes(bytes: number): string {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`;
    }
}

class CommitMessageModal extends Modal {
    onSubmit: (message: string) => void;

    constructor(app: App, onSubmit: (message: string) => void) {
        super(app);
        this.onSubmit = onSubmit;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.createEl('h2', { text: '创建版本' });

        const inputEl = contentEl.createEl('input', {
            type: 'text',
            placeholder: '输入提交信息...'
        });
        inputEl.style.width = '100%';
        inputEl.style.marginBottom = '10px';

        const buttonEl = contentEl.createEl('button', { text: '创建' });
        buttonEl.onclick = () => {
            const message = inputEl.value.trim() || '手动保存';
            this.onSubmit(message);
            this.close();
        };
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

class ConfirmModal extends Modal {
    title: string;
    message: string;
    onConfirm: (result: boolean) => void;

    constructor(app: App, title: string, message: string, onConfirm: (result: boolean) => void) {
        super(app);
        this.title = title;
        this.message = message;
        this.onConfirm = onConfirm;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.createEl('h2', { text: this.title });
        contentEl.createEl('p', { text: this.message });

        const buttonContainer = contentEl.createDiv();
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '10px';
        buttonContainer.style.justifyContent = 'flex-end';

        const cancelBtn = buttonContainer.createEl('button', { text: '取消' });
        cancelBtn.onclick = () => {
            this.onConfirm(false);
            this.close();
        };

        const confirmBtn = buttonContainer.createEl('button', { text: '确认' });
        confirmBtn.style.backgroundColor = '#e74c3c';
        confirmBtn.style.color = 'white';
        confirmBtn.onclick = () => {
            this.onConfirm(true);
            this.close();
        };
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}